# 方方面试押题

## HTML押题

1. 你是如何理解HTML语义化？
   - 用正确的标签做正确的事情，比如插入一段音频，应用audio标签，当我们看到这个标签就知道这个标签是做什么的
   - 即使没有css样式情况下，也能以一种文档格式显示。
   - 利于搜索引擎检索内容。
2. meta viewport是做什么用的，怎么写。

​              仅用于移动设备，来定义页面的初始尺寸，<meta name=“viewport” content=“width=device-width,initial-scale=1.0” />

​        控制页面在移动不要缩小显示。

3. canvas元素是干什么的?

​              canvas是一个画布，用过js可以绘制图表，图形，动画等等。

## CSS 押题

1. 说说盒模型
   - border-box 当我们写一个div的宽度为100px时，它包括了自身内容的宽度+边框宽度和内边距
   - content-box 它只是等于自身内容的宽度
2. css reset和normalize.css有什么区别? 

​               前者表示对浏览器的默认样式’清零’重置。后者表示让你的默认样式在每个浏览器上都是一致的。

3. 如何居中？

- 利用绝对定位，让left,top各位50%，在配合transform:translate(-50%,-50%)
- flex布局，display:flex;justify-content:center;align-items:center;
- 对于固定宽度的块级元素，左右的margin为auto。
- 对于行内元素使用text-align:center;vertical-align:middle;
- 使用display:table来模拟表格，子元素设置display:table-cell;同时用text-align:center;vertical-align:middle;便可水平垂直居中。

4. 选择器的优先级如何确定?

- 同一选择器写在后面的优先。
- 越具体越优先
- id选择器>类选择器，属性选择器，伪类选择器>元素选择器，伪元素选择器
- 行内样式表>内部样式表>外部样式表
- ! important优先级最高。

5. BFC是什么?

​             块级格式上下文，具有BFC特性的元素可以看作是隔离了的独立容器，容器里的元素不会在布局上影响到外面的元素。

6. 如何清除浮动。

- 对于float浮动的元素，使用:after伪元素，让它display:block;content:’’;clear:both;
- 给父元素添加overflow除了visible以外的值.(hidden，auto，scroll)
- <http://blog.csdn.net/c11073138/article/details/79451957>

## JS押题

1. JS有哪些数据类型?
   - number
   - boolean
   - string
   - null
   - undefined
   - object
   - symbol symbol类型的属性名都是独一无二的，不会与其它的属性名产生冲突。
2. Promise怎么使用？

​              Promise对象是一个构造函数，用来生成Promise实例。Promise构造函数接受一个函数作为一个参数，而这个函数有两个参数，是由JS引擎提供的，分别为resolve和reject，这两个参数也是函数。用来接受异步操作的值，可以自定义条件将异步的返回值作为参数传给resolve或reject。而生成的Promise实例又个then方法，它可以分别指定resolved状态和rejected状态的回调函数。

```
then
 $.ajax(...).then(成功函数，失败函数)
链式then
 $.ajax(...).then(成功函数1，失败函数1).then(成功函数1，失败函数1)
自己生成
  function xxx(){
    return new Promise(function(resolve,reject){
      //异步请求，
      //请求成功 reslove()
      //请求失败 reject()
    })
  }
  xxx().then(....)
```



3. AJAX手写一下？

   ```
   let xhr = new XMLHttpRequest()
   xhr.open('GET',url)
   xhr.onreadystatechange = function(){
     if(xhr.readyState===4){
       if(xhr.status>=200 &&xhr.status<400){
         //console.log(xhr.responseText())
       }else if(xhr.status>=400){
         //error
       }
     }
   }
   xhr.send()
   ```

4. 闭包是什么？

     闭包只是一种概念，假如在函数里面使用外面的参数，这就是闭包。通过闭包我们可以进行这样一个操作，比如你的饭卡有100元，即let money = 100,但是我们又不想money是全局的，这样每个人都可以修改它，只要把它放在函数A里的作用域下，外面作用域是拿不到这个值的，但是我们如何修改呢，我们可以让A return一个函数B，函数B可以进行对money的加减操作。这样在调用A函数就能操作money了。

5. 什么是立即执行函数？使用立即执行函数的目的是什么?

   - 顾名思义声明一个函数立马执行它，`!function(){console.log(1)}()`一般是声明一个匿名函数在前面加转换符(!,~,+,-),然后调用它。
   - 立即执行函数的实质就是创建一个独立的作用域，这个作用域里面的变量外面访问不到。如果把变量放在函数里，虽然隐藏了这个变量，但同时又暴露了这个函数。现在ES6出现了let声明，let声明的变量是块级作用域里的变量。在JS中，一个花括号可以表示为块级作用域。

6. async/await语法了解吗?目的是什么?

    ```
    function returnPromise(){
      return new Promise(function(resolve,reject){
        setTimeout(()=>{
          reslove('hello')
        },3000)
      })
    }
    returnPromise().then((result)=>{
      result === 'hello'
    })
    var result = await returnPromise()
    ```

    把异步代码写成同步代码

7. 如何实现深拷贝？

   深浅拷贝只针对复杂对象，浅拷贝只复制了一层对象的属性，而深拷贝则递归复制了所有层级。

   ```
   浅拷贝
   var obj = {a:1,arr:[2,3]}
   var shallowObj = shallowCopy(obj)
   function shallowCopy(src){
     var dst = {}
     for(var prop in src){
       if(src.hasOwnProperty(prop)){
         dst[prop] = src[prop]
       }
     }
     return dst
   }
   ```

   深拷贝  1. $.extend(true,{},obj) 2. JSON.parse(JSON.stringify(obj)) 缺点是JSON不支持函数，undefined,RegEx,Date

   ```
   function clone(object){
     var obj
     if(!(object instanceof Object)){
       return object
     }else if(object instanceof Array){
       obj = []
     }else if(object instanceof Function){
       obj = eval(objec.toString())
     }else if(object instanceof Object){
       obj = {}
     }
     for(let key in object){
       obj[key] = clone(object[key])
     }
     return obj
   }
   ```

8. 如何实现数组去重。

   1. indexOf:返回数组中可以找到一个给定元素的索引，不存在时为-1.

      ```
      var arr = [1,2,1,3,3,5,2,1]
      function filter(arr){
        let newArr = []
        if(arr.constructor===Array){
          arr.forEach(item=>{
            //用空数组找已知的key
            if(newArr.indexOf(item)===-1){
              newArr.push(item)
            }
          })
        }
        return newArr
      }
      ```

   2. 利用对象的属性的值是否存在。

      ```
      var arr = [1,2,1,3,3,5,2,1]
      var newArr = []
      var obj = {}
      arr.forEach(item=>{
        if(!obj[item]){
          obj[item] = 1
          newArr.push(item)
        }
      })
      console.log(newArr)
      ```

   3. 利用ES6提供的数组结构,Array.from(new Set(arr)) ,其中from会将伪数组或可迭代的对象转化为数组，Set类似于数组，但是成员的值都是唯一的。

   4. WeakMap任意类型去重????

9. 如何用正则实现string.trim()

    ```
       var str = ' hello world ! '
       str = str.replace(/^(\s*)|(\s*)$/g,'')
    ```

​        如果是中间的空格呢 `str.replace(/(\S)\s+(\b)/g,'$1$2')`

10. JS原型是什么?


​    对于一个对象来说，在我们声明时，它自身便存在一些熟悉。比如，我们创建一个空数组a，为什么这么会有push方法，因为浏览器默认会给数组绑定一个隐藏的属性a.__proto__，它指向了该数组的构造函数Array.prototype,这就是原型，用来存放公共的属性。

11. ES6中的class了解吗?

​       class可以看作对象原型的一个语法糖。

```
class a {say(){console.log(1)}}

let b = new a()

b.say()

function A(){}

A.prototype.say = function(){console.log(2)}

let B = new A()

B.say()

```


11. call,apply和bind的用法和区别是什么? https://juejin.im/entry/58785801128fe1006be5c6a9

    在JS中，call,apply和bind是Function对象自带的三个方法，三者都是用来改变函数的this对象的指向的。这三个的第一个参数都是this要指向的对象。bind返回对应的函数，便于稍后调用。而call,apply是立即调用。call和apply区别是call需要把参数按顺序传递进去，而apply则是把参数放在数组里。

## DOM押题

1. DOM事件模型是什么？
   1. 冒泡型事件：在事件发生时，首先在最精确的元素上触发，然后向上传播，直至根节点。IE
   2. 捕获型事件：事件发生时，首先在最顶级的元素上触发，然后向下传播，直至最低级的元素。
2. 移动端的触摸事件了解吗?
   1. touchstart
   2. touchmove
   3. touchend
   4. touch cancel
3. 事件委托是什么？有什么好处？
   1. 把想要被监听的元素委托给它父元素或祖先元素来监听。

   2. 好处是可以监听还不存在的元素，比如说，一个ul列表里，会动态增加li元素，如果不用事件委托，就得生成一个li标签就得监听一次，如果有一万个，拿不就存在一万个监听器，如果我们用事件委托ul标签来监听li标签，那就只需要一个监听器。

      ```
      function listen(element,eventType,selector,fn){
        element.addEventListener(eventType,e=>{
          let el = e.target
          while(!el.matches(selector)){
            if(element === el){
              el = null
              break
            }
            el = el.parentNode
          }
          el && fn.call(el,e,el)
        })
        return element
      }
      listen(ul,'click','li',()={})
      ul>li*5>span
      ```

      ​

## HTTP押题

1. HTTP状态码知道哪些?

   最常见有200,表示请求成功，301表示永久重定向(你请求的资源会永久的改成其他的URL来响应你)，302表示临时重定向。304表示not modified,你请求的资源没有改变，可以使用缓存。403表示服务器拒绝执行，404表示服务器请求失败，可能是请求的资源在服务器上找不到。405表示你请求的动作不能被用于请求相应的资源。500表示服务器内部出错，502表示网关问题。

2. HTTP缓存怎么做？

   缓存的目的是为了让没有变的内容不必要的重复下载。

   - Pragma: 响应头response.setHeader('Cache-Control','max-age=3600')，这就表示现在一个小时之内，我重新加载这个内容时会读取缓存里的内容，相对时间
   - Expires:response.setHeader('Expires',格林梅治时间)，绝对时间
   - Last-Modified
   - Etag,常见的是MD5算法，把一个文件映射为一串字符。

3. Cache-Control和Etag的区别是什么?

   1. Cache-Control接受一个相对时间，在这个时间内，即使你服务器上的内容发生了改变，浏览器照样使用缓存里的内容。除非手动加一个版本号。
   2. 而Etag，在第一次服务器响应你时，会将资源文件通过MD5算法映射成一段字符串，服务器会记录这段字符串，同时返回给客户端，等客户端第二次请求时，会将这段字符串传给服务器，如果服务器会比较这两个字符串是否相等，如果相等则说明内容没有改变，则返回304，表示你可以去读取浏览器上缓存的内容，如果不一致，就会重新下载这段资源文件，并更新该文件的Etag。

4. Cookie是什么？Session是什么？

   1. cookie是储存在浏览器上的一段数据，用来记录某些页面关闭或刷新时仍需要记录的信息。比如说，确认用户是否登陆，cookie可以使用JS在浏览器中直接设置，用来记录不敏感的信息，如用户名。也可以在服务器端使用HTTP协议规格的set-cookie来让浏览器种下cookie。一般浏览器储存cookie最大容量为4K,所以最好不要用来存储数据，因为每次网络请求都会带上cookie,这样会影响传输速率。
   2. Session的字面意思是会话，它可以弥补cookie的不足，因为cookie存在浏览器上，用户是能修改的。而session会把用户信息储存在服务器上，在服务器上开辟一块内存来储存，同时会使用cookie在相应头给你一个随机字符，就相当于一个ID，一个唯一ID对应服务器上一块内存上关联用户身份的对象。

5. LocalStorage是什么?与Cookie有什么区别?

   1. LocalStorage是浏览器的web storage提供一个API，用于将大量数据(最大为5M)永久储存在浏览器上。

   2. 区别是前者储存的数据只是浏览器里传输，而后者是在浏览器和服务器之间传输。

      ```
      之前，我写过一个游戏，它有这样一个需求，就是说这个游戏只能玩一次，你中途退出或刷新页面都不能再玩了，由于当时这个项目时间比较短，后台也没有提供相应的接口给我，我就只能通过前端判断。通过LocalStorage,在我加载这个页面，会读取localStorage的某个属性值是否为空，如果是空的，说明是第一次进来，并且设置一个非空值，第二次读取时，只要这个值非空，则强制返回上一页。
      ```

6. GET和POST的区别是什么？

   1. get有查询参数，没有消息体，post没有查询参数，有消息体
   2. get的url长度有限制，大概一千个字符长度，post的消息体大小没有限制，但也不能太大，大概4，5M左右。
   3. 语义的区别：get一般指获取内容，post是提交内容。
   4. 在实际工程上有很大区别：get只是获取数据，不需要带很大的数据量，一般把所有参数放在url里，这就导致了它没有消息体，ECP/Ip对于这种包只会发一个包文，但是post得一个一个的发，因为它有消息体。

7. 怎么跨域？JSONP是什么？CORS是什么？postMessage是什么？

   1. 跨域是指浏览器出于安全考虑的同源策略，禁止不同域之间相互调用AJAX，所用的解决方法，一般有三种。
   2. CORS是跨域资源共享的缩写，只要在服务器的响应头里设置一个域名白名单，response.setHeader('Cross-Control-Allow-Origin','xxx'),cors默认为post和get请求，若是其他的请求方法，则需要在响应头再加上Access-Control-Allow-Methods。CORS同时存在安全风险，因为要信任这个域名，如果域名被注入了XSS,怎会有很大的安全风险。同时IE8的兼容性也不好。
   3. JSONP针对于接口。

## Vue押题

1. Vue有哪些生命周期钩子函数?

   1. beforeCreate数据观测和事件配置之前。
   2. created实例创建后调用，异步请求可以使用这个钩子。
   3. beforeMount挂载之前。
   4. mounted根元素挂载到实例之后调用该钩子。
   5. beforeUpdate在数据更新时，虚拟dom渲染之前。
   6. updated，数据更新时，虚拟dom已渲染。
   7. activated，keep-alive组件激活时调用。
   8. deactivated,keep-alive组件停用时调用。
   9. beforeDestroy实例销毁之前调用。
   10. destroyed实例销毁之后调用，调用之后，Vue实例指示的所有东西会解除，事件监听也会被移除。

2. Vue如何实现组件通信?

   1. 父子之间的组件：数据从父到子(props),事件从子到父

   2. 兄弟之间：全局bus事件调度器,

      ```
      var Event = new Vue()

      Event.$emit()//触发
      Event.$on('xxx',function(){})//监听
      ```

      ​

   3. vuex：状态管理

   4. slot

3. Vuex的作用是什么?

4. VueRouter路由是什么？

5. Vue的双向绑定是如何实现的？有什么缺点？

6. Computed计算属性的用法？根Methods的区别？

## 算法押题

1. 排序算法(冒泡排序，选择排序，计数排序，快速排序，插入排序，归并排序)

   1. 冒泡排序(两两比较最大的放在后面)

      ```
      var arr = [3,44,38,5,47,15,5]
      function bubble(arr){
       for(var i=0;i<arr.length;i++){
        for(var j=0;j<arr.length-1;j++){
          if(arr[j]<=arr[j+1]){
            
          }else{
            swap(arr,j,j+1)
          }
        }
       }
       return arr
      }
      function swap(array,a,b){
        var temp = array[a]
        array[a] = array[b]
        array[b] = temp
      }
      bubble(arr)
      ```

   2. 选择排序(把最小的排到前面来)

      ```
      var arr = [3,44,38,5,47,15,5]
      function select(arr){
        let minIndex
        for(var i=0;i<arr.length;i++){
          minIndex = i
          for(var j=i+1;j<arr.length;j++){
            if(arr[minIndex]>arr[j]){
              minIndex = j
            }
          }
          if(minIndex !== i){
            swap(arr,i,minIndex)
          }
        }
        return arr
      }
      select(arr)
      ```

   3. 计数排序(桶排序)值域不可太大

      ```
      var arr = [3,44,38,5,47,15,5]
      function count(arr){
        let container = []
        let newArr = []
        for(var i=0;i<arr.length;i++){
          if(container[arr[i]]){
             container[arr[i]] += 1
          }else{
             container[arr[i]] = 1
          }
        }
       for(var i=0;i<container.length;i++){
         if(container[i]){
           for(var j=0;j<container[i];j++){
             newArr.push(i)
           }
         }
       }
       return newArr
      }
      count(arr)
      ```

   4. 快速排序(找中间基准，依次比较，小的都放在左边，大的都放在右边，通过递归)

      ```
      var arr = [3,44,38,5,47,15,5]
      function quicksort(arr){
        if(arr.length<=1){return arr}
        var pivotIndex = Math.floor(arr.length/2)
        var pivotValue = arr[pivotIndex]
        arr.splice(pivotIndex,1)
        var left = []
        var right = []
        for(var i=0;i<arr.length;i++){
          if(arr[i]<pivotValue){
            left.push(arr[i])
          }else{
            right.push(arr[i])
          }
        }
        return quicksort(left).concat(pivotValue,quicksort(right))
      }
      quicksort(arr)
      ```

   5. 插入排序(起牌算法)

      ```
      var arr = [3,44,38,5,47,15,5]
      function insert(arr) {
          var len = arr.length;
          var preIndex, current;
          for (var i = 1; i < len; i++) {
              preIndex = i - 1;
              current = arr[i];
              while(preIndex >= 0 && arr[preIndex] > current) {
                  arr[preIndex+1] = arr[preIndex];
                  preIndex--;
              }
              arr[preIndex+1] = current;
          }
          return arr;
      }
      insert(arr)
      ```

2. 二分查找法

   ```
   var Arr = [3, 5, 6, 7, 9, 12, 15];
   function binary(find, arr, low, high) {
       if (low <= high) {
           if (arr[low] == find) {
               return low;
           }
           if (arr[high] == find) {
               return high;
           }
           var mid = Math.ceil((high + low) / 2);
           if (arr[mid] == find) {
               return mid;
           } else if (arr[mid] > find) {
               return binary(find, arr, low, mid - 1);
           } else {
               return binary(find, arr, mid + 1, high);
           }
       }
       return -1;
   }
   binary(15, Arr, 0, Arr.length - 1);
   ```

3. 翻转二叉树


## 安全押题

1. 什么是XSS攻击？如何预防？

   1. 跨站脚本的代码注入，比如说，有一个评论系统，恶意用户提交评论`<script>console.log(document.cookie)</script>`,如果没有对内容进行过滤，当其他用户访问这个网站时，浏览器就会自动运行这段代码，而用户是无法察觉的。

      - 后台模版问题，内容没有经过任何过滤，只要把可疑符号'<','>'变成HTML的实体&lt,&gt,


      - 前端问题，解决办法就是不要使用拼接字符串的形式，尽量使用text方法，如果一定要使用HTML，就要把可疑符号变成HTML实体。

2. 什么是CSRF攻击？如何预防？

   1. 伪造请求，比如说一个黑客的网站时hack.com，它里面有一张图片，src是qq.com里面的某个接口，当我加载黑客网站时，这个接口就会被调用，那么服务器就分不清这是黑客的请求还是用户的请求。

      //攻击者伪造网站后台某个接口的请求，然后诱导用户去点击，那么用户在登陆状态下发的这个请求会被服务端误以为是用户合法操作。

   2. qq.com的页面可以拿到这个页面的数据或者是cookie，但黑客网站拿不到，只要你的请求带一个token,这个token可以与这个页面里任何数据或者cookie有关就可以了，证明了你是可以访问qq.com里面的数据。


## Webpack题

1. 转译出的文件过大怎么办？

2. HR，您好，请问贵公司还招Web前端吗?这是我的个人简历: http://shenfeng1945.top/resume

   ​


https://jscode.me/t/topic/2696

## 发散题

1. 从输入URL到页面展示中间发生了什么?

   1. DNS查询，DNS缓存
   2. 建立TCP连接(三次握手) 连接复用
   3. 发送HTTP请求(请求的四部分)
   4. 后台处理请求
      1. 监听80端口
      2. 路由
      3. 渲染HTML模版
      4. 生成响应
   5. 发送HTTP响应
   6. 关闭TCP连接(四次挥手)
   7. 浏览器解析HTML
   8. 下载CSS(缓存
   9. 解析CSS
   10. 下载JS(缓存
   11. 解析JS
   12. 下载图片
   13. 解析图片
   14. 渲染DOM树
   15. 渲染样式树
   16. 执行JS脚本

2. ［1,2,3].map(parseInt)

   ```
   parseInt(1,0,array) //1
   parseInt(2,1,array) //NaN
   parseInt(3,2,array) //NaN
   ```

3. (a == 1&& a==2&&a==3)可能为true吗?

   ```
   a = {
     value:0,
     toString(){
       a.value +=1
       retrun a.value
     }
   }
   ```

   ​


## 个人项目总结

1. 惠护爱真
   1. 库
      1. weui layui
      2. swiper.js轮播 chart.js用canvas做数据图 fastclick.js解决300ms延迟
      3. animate.css
   2. 技术
      1. 自动加载,query-weui,其实只要监听这个页面的滑动事件scroll,计算某个元素距离手机屏幕底部多少像素，然后发起请求，加载数据。
      2. 页面跳转 window.location.href 浏览器窗口有个history对象，用来保存浏览历史。history.pushState,指定跳转到某个页面，点击返回时会触发popstate事件
      3. 计算距离
   3. 微信缓存的问题
   4. iso的自动播放 监听WeixinJsBridgeReady事件，














### Alex老师

 * 毕业于卡内基梅隆大学，现任职于亚马逊AWS，从事云计算服务开发工作。有在腾讯，创业公司工作和作为独立开发者从事外包项目开发的经历。
 * 擅长云计算，分布式系统，Web后端开发，信息安全。现在主要学习和研究函数式编程和分布式系统相关领域。


 #### 课程大纲

 **中国和美国不同的求职体验**
 * 中美公司在招聘程序员面试中注重考察的能力
 * 如何提升自己的能力以适应不同公司的求职面试
 * 面对各种新兴技术，如何针对求职选择自己的技术方向

 **程序员职业生涯**

 * 中国和美国程序员的职业生涯路径的异同
 * 如何规划自己的程序员职业生涯
 * 程序员是否有职业天花板？终极问题：程序员是不是青春饭
 * 程序员的管理转型路径


 **云计算**
 * 云计算领域的现状和前景
 * 世界上最先进的云计算平台是怎么样的
 * 如何成为一个服务端或云计算程序员


 #### 直播时间
 2018年3月17日（本周六）20:30

 #### 进群交流
 添加班主任微信，备注：程序员职业路径
 青青：xiedaimala01
 圆圆：astak10
 墨凌：hungervalley

   

